<!DOCTYPE html><html><body><ul><li>How to use Git and GitHub <ul><li>Course<ul><li>Objective<ul><li><b>Lesson 1:</b> <ul><li>Cover the concept of version control and why use it</li></ul></li><li><b>Lesson 2:</b> <ul><li>Create a git <b><i>repository</i></b></li><li>Initialize and add <b><i>commits</i></b> to the repository</li><li>Use the <b><i>staging area</i></b> to control what changes go into each commits </li><li>Make parallel versions of the code with <b><i>git branches</i></b></li><li><b><i>Merge</i></b> two branches together</li></ul></li><li><b>Lesson 3:</b> <ul><li>Share a project and collaborate with other people<ul><li></li></ul></li></ul></li><li></li><li></li><li></li><li>Lesson 3: </li></ul></li><li>Strategy</li><li>Ambiente <ul><li>COURSE PLAYLIST <ul><li>https://www.youtube.com/playlist?list=PLAwxTw4SYaPk8_-6IGxJtD3i2QAu5_s_p</li></ul></li></ul></li><li>Conhecimento<ul><li>Nenhum</li></ul></li><li>Papéis</li><li></li></ul></li><li>Git Version Control System (Subjetct of the course)<ul><li>Objective<ul><li>Facilitar a colaboração em projetos de programação</li></ul></li><li>Strategy<ul><li>Saving different versions of your code and allow you to navigate through versions easily.</li></ul></li><li>Ambiente<ul><li>Git<ul><li>Version control system<ul><li>Sistema que permitem gerenciar de forma sistemática diversas versões de documentos (códgio, receitas, etc).</li><li>Cada versão registrada no sistema, é chamada de commit. </li></ul></li><li>Created by Linus Torvalds<ul><li>Git is a britsh slang for an unpleasent person and was chosen for funny reasons.</li></ul></li><li>Features<ul><li>Funciona com qualquer editor</li><li>Funciona offline</li><li>Exige que o usuário escolha quando salvar uma nova versão, criando commits.<ul><li>Commits versões do código que são criadas manualmente pelo usuário, permitindo que ele escolha quando criar, de acordo com o que fizer sentido para o usuário. <ul><li>exemplo de quando um commit deve ser criado:<ul><li>quando uma nova funcionalidade for implementada</li><li>quando um bug for corrigido</li><li>quando uma série de alterações foi finalizada e o código está pronto para ser compilado</li><li><del>uma mudança no códidgo do começo ao fim</del></li><li>etc</li></ul></li><li>Todo commit tem um pai. Utilize `git show` para ver a diferenças entre um pai e um filho</li></ul></li><li>Toda vez que um commit é criado, o git exige que o usuário forneça uma mensagem explicando o que tem de alteração naquela versão. <ul><li>Isso facilita navegar pelas versões. </li><li></li></ul></li></ul></li><li>Repository<ul><li>Grupo de arquivos</li></ul></li></ul></li></ul></li><li>Github<ul><li>Plataforma de colaboração e compartilhamento de código<ul><li>Estimula a prática do open source ao tornar repositórios abertos, gratuitos</li><li>Permite qualquer um propor alterações no código <ul><li>que são implementadas caso aprovadas pelos mantenedores do repositório</li><li></li></ul></li></ul></li></ul></li><li>Terminal UNIX<ul><li>terminal para navegação entre arquivos e uso da CLI git</li><li>Git CLI<ul><li>https://dynalist.io/d/msm2bDIbkBgzjMXq0Ms95-_R#z=oZlgd_ERknPpOuyjGv99osHs</li></ul></li><li>Customization<ul><li>Specific visual changes to the terminal to make it easy to use it with Git</li><li>Tools <ul><li>Hyper: Terminal Emulator</li><li>Zsh with Oh-My-Zsh: Z Shell (Zsh) is a UNIX command line interperter (or simply a "shell")  and Oh-My-Zsh is a framework for managing Zsh's configurations.</li><li>Spaceship: is a theme for Oh-My-Zsh</li></ul></li></ul></li></ul></li><li>Repository<ul><li>Directory with the project files + metadata files (.git folder)</li></ul></li></ul></li><li>Conhecimento<ul><li>Branches<ul><li>Branches <ul><li>are <ul><li>essentially<ul><li>a list of commits</li><li>that you can use `git log` to see the tip of th branch (latest commit) up to its first parent commit. </li><li></li></ul></li><li>useful when <ul><li>making experimental versions</li><li>a new language version</li><li>making a version to show to other team members</li><li>working simultraneously in different features</li><li>etc. </li></ul></li><li>assist in <ul><li>keeping the master as the production level branch that always works</li><li>keeping changes easy to manage and have a trail that leads back logically. Its all about making the paths logical. </li></ul></li></ul></li><li>can be <ul><li>created<ul><li>using git branch &lt;branchname&gt;</li><li>using git checkout -b &lt;branchname&gt;<ul><li>which creates and checks out the newly created branch</li></ul></li></ul></li><li>merged<ul><li>which means<ul><li>combining the commits of two branches to create a new branch<ul><li>most of the times it will be add the changes made in other branches<ul><li>into the master branch</li></ul></li><li></li></ul></li></ul></li></ul></li><li>deleted<ul><li>which means<ul><li>deleting the branch name but leaving the commits there in unreachable by that branch name<ul><li>the commits will then be only reachable temporarily by commit id</li><li>the commits will be deleted once Git's garbage collection runs<ul><li>this is sort of like a trash can <ul><li>but the difference is that it automatically happens from time to time <ul><li>or can be triggered manually with `git gc`</li></ul></li></ul></li></ul></li><li></li></ul></li><li></li></ul></li></ul></li><li></li></ul></li></ul></li><li>Example setups<ul><li>1 Master and many Dev Branches<ul><li>Master branch: <ul><li>production level work that is tested and QAd </li></ul></li><li>Development branches:<ul><li>work-in-progress work to be tested and QAd</li><li>gets updated from time to time from lastest PRs that got merged into master OR just get branched out from master after an update</li><li>can be 1 or more branches with different names. any branch that isnt the master is a development branch that will add to the master</li></ul></li><li></li></ul></li></ul></li></ul></li><li>Repository <ul><li>Local</li><li>Remote<ul><li>Shareable repository or simply a remote repository that syncs with a local or other remote repositories.</li><li>In case of a github remote,<ul><li>It only shows the commit history</li><li>You can't clone into it, since you don't have access to the folder<ul><li>you can only push commits from a local repository</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>Papéis</li><li>Procedimentos<ul><li>A. Find and Fix bugs<ul><li>1. Do `git log --stat` to see all the commits, their ids and the changes (via `--stat`)</li><li>2. Run the code, version by version - by doing git checkout &lt;commit-id&gt; - until you find a version that does not contain the bug<ul><li>Now you know that the bug is between the starting version and the current version that does not contain the bug</li><li>You can do this one by one from the most recent to the oldest</li><li>Or you can do this by memory, going back to where you knew it was working<ul><li>even though this older version may not have other updates, you just want to find the bug and you can fix it in the latest version</li></ul></li></ul></li><li>3. When you find the version the does not contain the bug use `git dif`f to compare the commit the "no-bug commit" to the "buggy commit" like this:<ul><li>`git diff &lt;no-bug-commit-id&gt; &lt;buggy-commit-id&gt;`<ul><li>example<ul><li>`git diff df035 25ede`<ul><li>you don't need to copy and paste the whole commit ID. </li><li>Just type the 4 or more first letters so that git can find it.</li></ul></li></ul></li></ul></li></ul></li><li>4. By using `git diff &lt;no-bug-commit-id&gt; &lt;buggy-commit-id&gt;` you will find the changes that were introduced which caused the bug</li><li>5. Play around in the buggy commit  to see if you can fix the bug and the replicate to the latest commit<ul><li>OR go directly to the latest commit and fix the bug there.</li><li>Commit to save the new version with that bug fixed. </li></ul></li></ul></li><li>B. Naviage through the commit history<ul><li>1. Open the terminal</li><li>2. Run `git log`<ul><li>add `--stat` to see what changed</li></ul></li><li>3. Use `git checkout &lt;comimt-id&gt;` to change your HEAD to another commit </li><li>4. Run the code and/or use git diff to see the changes between the current HEAD and other commits </li></ul></li><li>C. Create a repository<ul><li>1. Navigate to a folder you want the repository to be in or create a folder for it<ul><li>Navigate: cd &lt;folder-path&gt;</li><li>Create a folder: mkdir &lt;folder-path&gt; </li></ul></li><li>2. Do `git init` </li><li>3. A `.git` folder will be created but the repository will only be local</li></ul></li><li>D. Remember what changes you have added to stage<br>Useful when after making changes and commiting you need to remember what changes you worked on. This may be needed if you take a break for example, and come back later to finish the work.<ul><li>1. Run `git diff` with no arguments to see the changes between staging area and working directory</li></ul></li><li>E. See changes between Staging Area and Most Recent Commit<br>Useful for confirming if the changes added to staging are are as intented in relation to the most recent commit. <ul><li>1. Run `git diff --staged` </li></ul></li><li>F. Create a new branch and naviagete to it<ul><li>1. Run `git branch &lt;branch-name&gt;`</li><li>2. Run `git branch` to see all the branchs created locally and remotely<ul><li>2.1 The star/asterisk symbol next to a branch name indicates the checkouted branch</li></ul></li><li>3. Run `git checkout &lt;newly-created-branch-name&gt;`</li></ul></li><li>G. Merge Branches<ul><li>1. Go the branch you want the commits to merge <b>into</b>. In most cases this will be the master branch.</li><li>2. Run `git merge &lt;branch-name-1&gt; &lt;branch-name-2&gt; &lt;branch-name-2&gt; etc...` <ul><li>This merges one or more branches into the current branch.<ul><li>the branch you specify on the command will be merged into branch you are. </li></ul></li></ul></li></ul></li><li>H. How to Solve <b>Merge Conflicts</b><ul><li><b><i>Message:</i></b><ul><li>`Automatic merge failed; fix conflicts and then commit the result.`<ul><li>Fix it with:<ul><li>GENERAL FIX<ul><li>1. Restoring your files to their state before you started the merge by running:<ul><li>`git merge --abort`</li></ul></li><li>2. Double check the state of your files, running<ul><li>`git log`<ul><li>Look for the latest commit you have done by using `git show`</li></ul></li></ul></li><li>3. Open the files that had conflicts and look for these <b><i>special markers</i></b> marking the conflicting commits:<ul><li><b><i>Special markers:</i></b><ul><li>A. `&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD` and `||||||| merged common ancestors`<ul><li>between these two is the <b><i>current branch commit</i></b></li></ul></li><li>B. `||||||| merged common ancestors` and `=======`<ul><li>between these two is the <b><i>common ancestor commit of both branches</i></b></li></ul></li><li>C. `=======` and `&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;conflicting-branch-name&gt;`<ul><li>between these two is the <b><i>merging branch commit</i></b> that is conflicting with the <b><i>current branch commit</i></b></li></ul></li></ul></li></ul></li><li>3. Fix the conflict by choosing one of the 3 conflicting commits (A, B or C) and if needed making incremental changes and deleting the special markers.<ul><li>Incremental changes may be <ul><li>Using parts of one or more of the  A, B, C commits to create a new final version</li><li>Simply adding a new change elsewhere and keeping one of the options.</li></ul></li></ul></li><li>4. Once are in the correct state, create a new commit with your changes (not sure why?)</li><li>5. Try the merge again</li></ul></li></ul></li><li>Possible Windows vs Unix Fix<ul><li>Due to differences in the "Enter" character code between Unix and Windows<ul><li>Unix uses<ul><li>LF<ul><li>`line feed`</li></ul></li></ul></li><li>Windows uses<ul><li>`carriege return` and `line feed`<ul><li>or simply<ul><li>CRLF</li></ul></li></ul></li></ul></li></ul></li><li>So files edited in each system will have different enter characters and this may cause merge conflicts.</li><li>To fix this, Windows users should set the global autocrlf attibute to true with<ul><li>`git config --global core.autocrlf true`</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>I. Sync a Local Repo with a Remote Repo (such as GitHub)<ul><li>1. Run `git init` to initialize git in a folder, turning the folder into a repositiory</li><li>2.  Do a commit <ul><li>Run `git add &lt;file&gt; _or_ &lt;files&gt;`</li><li>Run `git commit -m "commit message`<ul><li>Usually a shared repo is started by:<ul><li>2.1 Creating a README.md file<ul><li>which will contain instructions for others accessing your repository</li></ul></li><li>2.2 Adding this readme file to the staging area</li><li>2.3 Commiting this as the "<i>inital commit</i>"</li></ul></li><li></li></ul></li><li>3. Run `git push` to upload commits to remote repository<ul><li>Only reachabe commits on the branch you are will be uploaded.</li></ul></li></ul></li></ul></li><li>J. Create a repository in GitHub<ul><li>1. Create and login to your Github account</li><li>2. Click on the plus sign and choose "New Repository"</li><li>3. Choose either public or private </li><li>4. Choose <i>"Initialize this repository with a README"</i> to start already with a README file that you can add info about your repo from the start. </li><li>5. Add a list of files that Git should ignore by adding them to the .gitignore<ul><li>Suggestions for<ul><li>Mac<ul><li>.DS_Store</li></ul></li><li>Windows<ul><li>desktop.ini</li><li>thumb.db</li></ul></li></ul></li></ul></li><li>6. Add a license if needed</li><li>7. Press "Create Repository"</li></ul></li><li>K. Push existing local repository to a remote repository<ul><li>1. Using `git remote`</li></ul></li></ul></li><li>Results<ul><li>Eficiência<ul><li>Achar erros em questão de minutos ao invés de horas<ul><li>especialmente quando os arquivos são grandes (+ de 100 linhas, por exemplo)</li></ul></li></ul></li><li>Colaboração<ul><li>Permite que várias pessoas trabalhem simultâneamente. </li><li></li></ul></li></ul></li></ul></li><li>Métricas</li></ul></li></ul></body></html>